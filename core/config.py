"""
Sistema de configuração para o Gemini Coder.
"""

import os
import json
from typing import Dict, Any, Optional
from pathlib import Path
from dataclasses import dataclass, asdict


@dataclass
class Config:
    """Configuração do Gemini Coder."""
    
    # API Configuration
    gemini_api_key: str = ""
    gemini_model: str = "gemini-1.5-flash"
    
    # Interface Configuration
    use_rich_interface: bool = True
    show_line_numbers: bool = True
    auto_confirm: bool = False
    
    # Memory Configuration  
    memory_file: str = ".gemini_memory.json"
    max_history_entries: int = 100
    max_context_files: int = 50
    
    # Tool Configuration
    enable_dangerous_commands: bool = False
    command_timeout: int = 30
    
    # Git Configuration
    auto_git_add: bool = False
    commit_message_template: str = "feat: {action} - Generated by Gemini Coder"
    
    # File Configuration
    max_file_size: int = 1024 * 1024  # 1MB
    ignored_extensions: list = None
    
    def __post_init__(self):
        if self.ignored_extensions is None:
            self.ignored_extensions = ['.pyc', '.pyo', '.pyd', '.db', '.sqlite']
    
    @classmethod
    def load(cls, config_path: Optional[str] = None) -> 'Config':
        """Carrega configuração de arquivo ou variáveis de ambiente."""
        config = cls()
        
        # 1. Carregar de variáveis de ambiente
        config._load_from_env()
        
        # 2. Carregar de arquivo de configuração
        if config_path:
            config._load_from_file(config_path)
        else:
            # Tentar carregar de locais padrão
            for path in config._get_default_config_paths():
                if os.path.exists(path):
                    config._load_from_file(path)
                    break
        
        return config
    
    def _load_from_env(self):
        """Carrega configuração de variáveis de ambiente."""
        # Tentar carregar arquivo .env se existir
        try:
            from dotenv import load_dotenv
            load_dotenv()  # Carrega .env do diretório atual
        except ImportError:
            pass  # python-dotenv não instalado
        
        env_mappings = {
            'GEMINI_API_KEY': 'gemini_api_key',
            'GEMINI_MODEL': 'gemini_model',
            'GEMINI_MEMORY_FILE': 'memory_file',
            'GEMINI_AUTO_CONFIRM': ('auto_confirm', bool),
            'GEMINI_MAX_HISTORY': ('max_history_entries', int),
            'GEMINI_COMMAND_TIMEOUT': ('command_timeout', int),
        }
        
        for env_var, config_attr in env_mappings.items():
            value = os.getenv(env_var)
            if value:
                if isinstance(config_attr, tuple):
                    attr_name, attr_type = config_attr
                    if attr_type == bool:
                        value = value.lower() in ('true', '1', 'yes', 'on')
                    elif attr_type == int:
                        value = int(value)
                    setattr(self, attr_name, value)
                else:
                    setattr(self, config_attr, value)
    
    def _load_from_file(self, config_path: str):
        """Carrega configuração de arquivo JSON."""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
            
            for key, value in config_data.items():
                if hasattr(self, key):
                    setattr(self, key, value)
        
        except Exception as e:
            print(f"Erro ao carregar configuração de {config_path}: {e}")
    
    def _get_default_config_paths(self) -> list:
        """Retorna caminhos padrão para arquivos de configuração."""
        return [
            ".gemini_config.json",  # Local do projeto
            os.path.expanduser("~/.gemini_config.json"),  # Home do usuário
            os.path.expanduser("~/.config/gemini-coder/config.json"),  # XDG config
        ]
    
    def save_to_file(self, config_path: str):
        """Salva configuração em arquivo."""
        try:
            os.makedirs(os.path.dirname(config_path), exist_ok=True)
            
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(asdict(self), f, indent=2, ensure_ascii=False)
        
        except Exception as e:
            print(f"Erro ao salvar configuração: {e}")
    
    def validate(self) -> list:
        """Valida configuração e retorna lista de erros."""
        errors = []
        
        if not self.gemini_api_key:
            errors.append("GEMINI_API_KEY não está configurado")
        
        if self.command_timeout <= 0:
            errors.append("command_timeout deve ser maior que 0")
        
        if self.max_history_entries <= 0:
            errors.append("max_history_entries deve ser maior que 0")
        
        if self.max_file_size <= 0:
            errors.append("max_file_size deve ser maior que 0")
        
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        """Converte configuração para dicionário."""
        return asdict(self)
    
    def get_display_config(self) -> Dict[str, Any]:
        """Retorna configuração para exibição (sem dados sensíveis)."""
        config = self.to_dict()
        
        # Mascarar API key
        if config['gemini_api_key']:
            config['gemini_api_key'] = config['gemini_api_key'][:8] + "..." + config['gemini_api_key'][-4:]
        
        return config


class ConfigManager:
    """Gerenciador de configuração."""
    
    def __init__(self, config_path: Optional[str] = None):
        self.config_path = config_path
        self.config = Config.load(config_path)
    
    def get_config(self) -> Config:
        """Obtém configuração atual."""
        return self.config
    
    def update_config(self, **kwargs):
        """Atualiza configuração."""
        for key, value in kwargs.items():
            if hasattr(self.config, key):
                setattr(self.config, key, value)
    
    def save_config(self, path: Optional[str] = None):
        """Salva configuração."""
        save_path = path or self.config_path or ".gemini_config.json"
        self.config.save_to_file(save_path)
    
    def validate_config(self) -> bool:
        """Valida configuração atual."""
        errors = self.config.validate()
        if errors:
            print("Erros na configuração:")
            for error in errors:
                print(f"  - {error}")
            return False
        return True
    
    def create_sample_config(self, path: str = ".gemini_config.json"):
        """Cria arquivo de configuração de exemplo."""
        sample_config = Config()
        sample_config.gemini_api_key = "your_api_key_here"
        
        sample_dict = asdict(sample_config)
        sample_dict['_comment'] = "Arquivo de configuração do Gemini Coder - Edite conforme necessário"
        
        try:
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(sample_dict, f, indent=2, ensure_ascii=False)
            
            print(f"Arquivo de configuração de exemplo criado: {path}")
            print("Por favor, edite o arquivo e adicione sua GEMINI_API_KEY")
        
        except Exception as e:
            print(f"Erro ao criar arquivo de configuração: {e}")


def load_config(config_path: Optional[str] = None) -> Config:
    """Função helper para carregar configuração."""
    return Config.load(config_path)